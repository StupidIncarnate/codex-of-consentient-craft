import { formatTypeSafetySectionLayerBroker } from './format-type-safety-section-layer-broker';
import { formatTypeSafetySectionLayerBrokerProxy } from './format-type-safety-section-layer-broker.proxy';
import { MarkdownSectionLinesStub } from '../../../contracts/markdown-section-lines/markdown-section-lines.stub';

describe('formatTypeSafetySectionLayerBroker', () => {
  it('VALID: {} => returns complete markdown section for type safety rules', () => {
    formatTypeSafetySectionLayerBrokerProxy();

    const result = formatTypeSafetySectionLayerBroker();

    const expected = MarkdownSectionLinesStub({
      value: [
        '## TypeScript & Type Safety',
        '',
        '### Strict Typing Required',
        '',
        '**Strict typing required - No type suppression allowed**',
        '',
        '- Never use @ts-ignore or @ts-expect-error',
        '- Use Zod contracts instead of primitives - All string/number parameters must use branded Zod types',
        '- All exported functions must have explicit return types using Zod contracts',
        '- Use existing types from codebase or create new ones',
        '',
        '### For Uncertain Data',
        '',
        '**For uncertain data (external inputs, API responses, catch variables, JSON.parse): Use unknown and validate through contracts**',
        '',
        '**Example:**',
        '```typescript',
        'export const handleError = ({error}: {error: unknown}): ErrorMessage => { if (error instanceof Error) { return errorMessageContract.parse(error.message); } if (typeof error === "string") { return errorMessageContract.parse(error); } return errorMessageContract.parse("Unknown error"); };',
        '```',
        '',
        '### Fix at Source',
        '',
        '**Never suppress errors - fix at source**',
        '',
        '**Violations:**',
        '```typescript',
        '// @ts-ignore const result = dangerousOperation();',
        '',
        '// @ts-expect-error const value = user.nonExistentProperty;',
        '',
        '```',
        '',
        '**Correct approach:**',
        '```typescript',
        'Create proper Zod contracts instead: export const apiResponseContract = z.object({data: z.array(userContract), meta: z.object({total: z.number().int().brand<"TotalCount">()})}); export type ApiResponse = z.infer<typeof apiResponseContract>;',
        '```',
        '',
        '### Type Inference',
        '',
        '**Let TypeScript infer when values are clear, be explicit for: empty arrays/objects, ambiguous values, ALL exported functions**',
        '',
        '**Examples:**',
        '```typescript',
        'const users: User[] = []; // Explicit for empty',
        'const config: Record<UserId, User> = {}; // Explicit for empty',
        'const userId = user.id; // Inferred from user type (already branded)',
        'const names = users.map(u => u.name); // Inferred from array (already branded)',
        '```',
        '',
        '**Violations:**',
        '```typescript',
        'const data: any = response.data; // Loses all type safety',
        '```',
        '',
        '### Type Assertions vs Satisfies',
        '',
        '**Using `satisfies`:**',
        '',
        'Use satisfies to validate object structure while preserving inference',
        '',
        '```typescript',
        'const config = { apiUrl: "http://localhost", port: 3000, } satisfies Partial<Config>; // Validates structure, keeps literal types',
        '```',
        '',
        '**Using `as`:**',
        '',
        'Use as only when you have information compiler lacks (JSON.parse, external data)',
        '',
        '**Examples:**',
        '```typescript',
        'const data = JSON.parse(response) as ApiResponse;',
        '```',
        '',
        '**Violations:**',
        '```typescript',
        'const broken = {} as ComplexType; // Hides missing properties',
        '```',
        '',
        '**Important:** Never use as to bypass type errors - fix the type instead',
        '',
        '### Function Arguments vs Return Types',
        '',
        '**ban-primitives rule: Inputs allow primitives, returns require branded types**',
        '',
        '- Input args can use raw primitives (inline object types)',
        '- Return types must use branded types/contracts',
        '',
        '**Examples:**',
        '```typescript',
        'export type SomeService = { doSomething: (params: {name: string; count: number}) => Result; getUser: () => User; getConfig: () => {apiKey: ApiKey; timeout: Milliseconds}; };',
        '',
        'export const loadConfig = (): Config => { return configContract.parse({apiUrl: process.env.API_URL || "http://localhost:3000", timeout: parseInt(process.env.TIMEOUT || "5000")}); };',
        '',
        '```',
        '',
        '**Violations:**',
        '```typescript',
        'export const badFunction = ({userId, name}: {userId: string; name: string}) => { /* Use UserId and UserName contracts instead */ };',
        '```',
        '',
        '### No Raw Primitives',
        '',
        '**Never use raw primitives in function signatures - always use branded types from contracts**',
        '',
        '**Violations:**',
        '```typescript',
        'export const badFunction = ({userId, name}: {userId: string; name: string}) => { /* Use UserId and UserName contracts instead */ };',
        '```',
        '',
        '**Examples:**',
        '```typescript',
        'export const goodFunction = ({userId, name}: {userId: UserId; name: UserName}): Result => { /* implementation */ };',
        '```',
        '',
        '### Cross-Domain Branded Types',
        '',
        '**Rule:** When passing branded values between domains, parse through the target contract to re-brand',
        '',
        '**Rationale:** Branded types enforce domain boundaries. StepId and DagNodeId are both branded strings but NOT assignable to each other.',
        '',
        '**LLM Training Violation:** LLM training instinct: Use type assertion (as unknown as TargetType) to bypass brand mismatch. This defeats the purpose of branding.',
        '',
        '**Examples:**',
        '```typescript',
        'const dagNodeId = dagNodeIdContract.parse(stepId); // Re-brands via contract validation',
        '```',
        '',
        '**Violations:**',
        '```typescript',
        'const dagNodeId = stepId as unknown as DagNodeId; // Type assertion bypasses brand safety',
        '',
        'const dagNodeId: DagNodeId = stepId; // Type error - brands are incompatible',
        '',
        '```',
        '',
      ],
    });

    expect(result).toStrictEqual(expected);
  });
});
