/**
 * PURPOSE: Formats the type safety section of the universal syntax rules markdown
 *
 * USAGE:
 * const lines = formatTypeSafetySectionLayerBroker();
 * // Returns array of markdown lines for type safety rules
 */
import type { MarkdownSectionLines } from '../../../contracts/markdown-section-lines/markdown-section-lines-contract';
import { markdownSectionLinesContract } from '../../../contracts/markdown-section-lines/markdown-section-lines-contract';
import { universalSyntaxRulesStatics } from '../../../statics/universal-syntax-rules/universal-syntax-rules-statics';

export const formatTypeSafetySectionLayerBroker = (): MarkdownSectionLines => {
  const { typeSafety } = universalSyntaxRulesStatics;
  return markdownSectionLinesContract.parse([
    '## TypeScript & Type Safety',
    '',
    '### Strict Typing Required',
    '',
    `**${typeSafety.strictTyping.rule}**`,
    '',
    `- ${typeSafety.strictTyping.noTypeSuppression}`,
    `- ${typeSafety.strictTyping.useContracts}`,
    `- ${typeSafety.strictTyping.explicitReturnTypes}`,
    `- ${typeSafety.strictTyping.useExistingTypes}`,
    '',
    '### For Uncertain Data',
    '',
    `**${typeSafety.uncertainData.rule}**`,
    '',
    '**Example:**',
    '```typescript',
    ...typeSafety.uncertainData.examples,
    '```',
    '',
    '### Fix at Source',
    '',
    `**${typeSafety.fixAtSource.rule}**`,
    '',
    '**Violations:**',
    '```typescript',
    ...typeSafety.fixAtSource.violations.flatMap((violation) => [violation, '']),
    '```',
    '',
    '**Correct approach:**',
    '```typescript',
    typeSafety.fixAtSource.correctApproach,
    '```',
    '',
    '### Type Inference',
    '',
    `**${typeSafety.typeInference.rule}**`,
    '',
    '**Examples:**',
    '```typescript',
    ...typeSafety.typeInference.examples,
    '```',
    '',
    '**Violations:**',
    '```typescript',
    ...typeSafety.typeInference.violations,
    '```',
    '',
    '### Type Assertions vs Satisfies',
    '',
    '**Using `satisfies`:**',
    '',
    typeSafety.typeAssertions.satisfies.rule,
    '',
    '```typescript',
    ...typeSafety.typeAssertions.satisfies.examples,
    '```',
    '',
    '**Using `as`:**',
    '',
    typeSafety.typeAssertions.as.rule,
    '',
    '**Examples:**',
    '```typescript',
    ...typeSafety.typeAssertions.as.examples,
    '```',
    '',
    '**Violations:**',
    '```typescript',
    ...typeSafety.typeAssertions.as.violations,
    '```',
    '',
    `**Important:** ${typeSafety.typeAssertions.neverBypassErrors}`,
    '',
    '### Function Arguments vs Return Types',
    '',
    `**${typeSafety.functionSignatures.rule}**`,
    '',
    `- ${typeSafety.functionSignatures.inputsAllowPrimitives}`,
    `- ${typeSafety.functionSignatures.returnsMustUseBranded}`,
    '',
    '**Examples:**',
    '```typescript',
    ...typeSafety.functionSignatures.examples.flatMap((example) => [example, '']),
    '```',
    '',
    '**Violations:**',
    '```typescript',
    ...typeSafety.functionSignatures.violations,
    '```',
    '',
    '### No Raw Primitives',
    '',
    `**${typeSafety.noRawPrimitives.rule}**`,
    '',
    '**Violations:**',
    '```typescript',
    ...typeSafety.noRawPrimitives.violations,
    '```',
    '',
    '**Examples:**',
    '```typescript',
    ...typeSafety.noRawPrimitives.examples,
    '```',
    '',
    '### Cross-Domain Branded Types',
    '',
    `**Rule:** ${typeSafety.crossDomainBranding.rule}`,
    '',
    `**Rationale:** ${typeSafety.crossDomainBranding.rationale}`,
    '',
    `**LLM Training Violation:** ${typeSafety.crossDomainBranding.llmTrainingViolation}`,
    '',
    '**Examples:**',
    '```typescript',
    ...typeSafety.crossDomainBranding.examples,
    '```',
    '',
    '**Violations:**',
    '```typescript',
    ...typeSafety.crossDomainBranding.violations.flatMap((violation) => [violation, '']),
    '```',
    '',
  ]);
};
